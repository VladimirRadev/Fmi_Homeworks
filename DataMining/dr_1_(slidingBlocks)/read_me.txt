***Интелигентни системи Софтуерно инженерство курс 4 зимен семестър Домашно 1 ***
Владимир Радев фн.62530 група 1

- За решаването на задачата съм използвал IDA* и manhatton за евристична функция, като съм използвал предоставения псевдокод от вас на упражнения.
- Където съм сметнал че е подходящо съм поставил коментари , за да може всичко да е ясно
- При обхождането на дървото от състояния съм използвал class-ът Node , в който се съдържа информация за :
	1) матрица от интове, която представлява  текущия вид на дъската
	2) g - броят обходени Node-ве до момента
	3) h - manhatton-а на текущият Node, като във метода preComputeH(), преизчислявам манхатъна спрямо предишния node и текущият като взимам във сметката само две блокчета ( нулата и числото , с което ще се размени спрямо една от 4те посоки ( left,right,up,down))
	4) pathToTheNode - вектор от вида : пр. {"left", "left" ,"up" ,.. } - пази изминатият път до текущият node
	5) blankSquareIndexes - pair с координатите на нулата, за да знам къде е нулата в този момент и да ми е по- лесно да добавям децата
-ida_star() и search() функциите са идентични на псевдокода
-successors фунцкията създава нови node-ве , които са наследниците на текущият node , вкарва ги в приоритетна опашка и ги подрежда спрямо приоритетa f - ( f(n)= g(n) + h(n), разтоянието изминато до момента + евристичната функция ) и връща като резултат - тази приоритетна опашка.
-в крайна сметка когато се намери решение, се взима последния елемент от path , в който е складиран и отговорът - оптималния брой стъпки до решение - g  и pathToTheNode.
-ПРИ ОТКОМЕНТИРАНЕ НА РЕД 519 , ЩЕ МОЖЕ ДА ВИДИТЕ ВРЕМЕТО ЗА ИЗПЪЛНЕНИЕ НА ПРОГРАМАТА, БЕЗ ДА ВКЛЮЧВАМ ПРИНТИРАНЕТО ! ! !

	->ДОПЪЛНИТЕЛНО СЪМ ДОБАВИЛ В АРХИВА:
	->>.exe файл , с който съм тествал в judge-а
	->> proof_of_grade.PNG, - това което изкарва при мен judge-a
	->>.cpp- самият код на задачата написан на C++ 