Владимир Валентинов Радев СИ 2 Курс 1 група

Домашно 2 ОС


--------------------------------------------


exit status  1 -> Грешка от логиката на програмата
еxit status  2 -> Системна грешка при извикване на някоя от функциите ( напр. write ,read ,open и тн.)


Започваме от мейна..
Условието на задачата е че трябва нашата програма да приема един параметър, тоест проверяваме това и ако има различен брой
от 2 аргумента ( име на самата програма и име на двоичния файл подаден като аргумент програмата гърми). 

След това отваряме самият подаден
файл за четене само и проверяваме дали той е с размер >= 7 байта ( толкова е хедъра) и дали има n на брой команди ( всяка по 25 байта, 
като n>=0) и ако това не е изпълнено значи има грешка от логиката на програмата и приключваме със статус 1.

!! имаме 3 помощни стуктури header_t(char magicWord[3]; uint32_t ram_size), command_t(uint8_t opcode,int64_t opr1,int64_t opr2,int64_t opr3)
, oprAttributes_t(int fd; header_t* header;command_t* command; int64_t* ram_cells;bool* setIndexes), като трите съдържат
правилните типове на аргументите които ще четем от байнъри файла и са създадени
за удобство при четенето и след това за удобна работа с цялостната информация на задачата 


Прочитаме хедъра и ако магическата дума не е ОРC програмата приключва с 1.


След това заделяме памет за двата основни масива с които ще работим ram_cells и setINdexes , ram_cells е масива с клетки от рамта , в 
които ние извършваме всички операции ( той е с размер толкова байта колкото е числото ram_size в хедъра * размера на всяка една клетка 
от него (по условие 8 байта )) този масив може и да е с размер 0 като тогава още при първата операция с него просто програмата ще гръмне.
Вторият е такъв който е със същия размер като ram_cells обаче отговаря затова да помним коя клетка има записана информация в нея чрез команда
от самата виртуална машина ( така при опит за прочит на стойност от клетка която не е била инициализирана предварително , програмата ще гърми)
Този масив setIndexes е боол масив и в началото навсяка еднна позиция стойноста е сетната на false чрез memset (man 3 от там прочетох как се ползва)

После инициализираме oprAtt коята е структура която складира информация за всичко в програмата и която просто се подава като аргументи на различните функции
за да не претрупваме кода с излишни аргументи ( подаваме я като поинтер , като така работим директно с нея , а не правим копия което би ни забавило програмата)


Основна логика:

	Въртим един while който прочита команда записва я в oprAtt.command и след това подаваме oprAtt на findCommand функцията, ако не сме успели да прочетем команда
програмата гърми с статус 2.

	
0) void findCommand(oprAttributes_t* oprAtt) е функцията която просто прави 13 проверки (12 актуални кода от таблицата + ако сме подали 
невалидна команда -> тогава пак гърмим с еxit status 1) за това реално кой opcode сме прочели в командата и предава към функцията изпълняваща логиката стояща зад самия opcode



1) //set (tar , val)
void set(oprAttributes_t* oprAtt)
	Функция която проверява дали се опитваме да запишем на актуален адрес ( [0,ram_size) ) и ако не е гърми с статус 1 , а ако е актуален 
просто записваме в ram_cells[tar] = val и също така казваме че setIndexes[tar]=true , тоест там вече е инициализирана стойност и ако някой иска да чете от там няма да е проблем



2) //load (to ,from_ptr)

void load(oprAttributes_t* oprAtt)

	Функция, каято проверява първо дали подадените аргументи са валидни адреси и ако са взима стойноста от ram_cells[from_ptr] и вече за нея проверява дали и тя е актуален адрес
и ако да тогава проверява дали и на този адрес има инициализирана стойност и ако да сетва ram_cells[to]=ram_cells[ram[from_ptr]]
Ако някоя от стъпките не е изпълнена програмата гърми ( тоест важно е дясната част на оператор= да е сетната за да можем да вземем стойноста от там и да я запишем в лявата част на 
оператор=) . След записване вече казваме и че setIndexes[to]=true


3)//out (v)
void out(oprAttributes_t* oprAtt)
	Функция, която проверява дали v е актуален адрес на клетка дали там е сетната стойонст и ако да принти на 1 ( stdout) символа с аски код числото ram_cells[v] (това е дефаулта
на write - дори да му подадем число то се опитва да го репрезентира като символ с аски код това число). Ако проверките не минат гърми с 1 , ако write не изпринти тогава програмта гърми с 2




4)//store (to_ptr,from)
void store(oprAttributes_t* oprAtt)

	Функция която е идентична на лоад само че e в обратния ред , т.е ram_cells[ram_cells[to_ptr]]=ram[from] . Проверките са същите като при лоад.

5)//jmp(idx)
void jmp(oprAttributes_t* oprAtt)

	Функция която проверя дали е подаден валиден индекс , дали на този индекс е сетната стойност и ако да просто с lseek seek_set преместваме курсора на файла
до команда с индекс числото ram_cells[idx] ( хедъра е 7 байта + ram_cells[idx]*(размера на единична команда е 25 байта)) . Kaто след това проверяваме дали случайно не сме скочили на 
команда с индекс надхвърлящ броят на актуалните команди във файла , като се опитаме да прочетем команда след сетването ако резултата от read- a даде <=0 значи нищо не сме прочели и това значи
че този индекс е невалиден -> гърми с 1 . А ако се опитаме още в началото да сетнем на негативен размер байтове , то самия лсеек ще изгърми с -1 ( това се случва когато ram_cells[idx]<0)


6)//sgz(v)
void sgz(oprAttributes_t* oprAtt)

	Функция която проверява дали е подаден валиден индекс , дали на този индекс е сетната стойонст и проверява дали на този индекс стойноста от ram_cells[v] > 0 , ако е изпълнено
премества курсора с lseek seek_cur + размера на една команда ( 25 байта) . Приемам че дори sgz да е последна команда и да кажем прескочи следващата то реално няма следващи така че просто ще приключи четенето
( не хвърлям грешка). А ако е трябвало да хвърли грешка проверката е анологична на последния случай на jmp където просто се опитва да прочете нова команда и ако не може връща грешка , а ако може връща с едно назад и 
продължава изпълненнието


7) //add (res,v1,v2);
void add(oprAttributes_t* oprAtt)
  Всички аргументи трябва да са валидни индекси , v1 i v2 трябва да са сетнати клетки и ако всичко това е изпълнено просто казваме ram_cells[res]=ram_cells[v1]+ram_cells[v2] и след това
разбира се setIndexes[res] = true


8) //mul(res,v1,v2)
void mul(oprAttributes_t* oprAtt)
	Същата като адд само че oперацията е * (умножение)

9)//div(res,v1,v2)

void div_func(oprAttributes_t* oprAtt)

   Същата като адд само че трябва да проверим дали ram_cells[v2] == 0 ако да тогава гърми с опит за делене на нула , а ако е различно 
просто записва в ram_cells[res] = ram_cells[v1]/ram_cells[v2]

10) //mod(res,v1,v2)
void mod(oprAttributes_t* oprAtt)

	Същата като div_func само дето операцията / (delene ) е заместена с % ( остатък при делене)

11) //sleep(v)

void sleep_func(oprAttributes_t* oprAtt)
	Функция която проверява дали е подаден валиден индекс , дали на този индекс е сетната стойонст и ако ram_cells[v] < 0 също гърми с статус 1 , защото 
не можем да подадем на функцията sleep(negative) , тя приема unsigned число. След това извикваме просто sleep(ram_cells[v]/1000) защото в условието на задачата се казва че на sleep 
се подават miliseconds а реално sleep работи със seconds (man 3)

12 ) nop
	Даже не съм я дефинирал. Просто в findCommand щом влезне в ifa за нея просто returnva и продължава с четенето на следващата команда
	



Накрая на мейна освобождаваме заделенета на хийпа памет за ram_cells i setINdexes чрез free() фунцкията и затваряме байнъри файлът подаден като аргумент на програмата 
Приключваме с 0 ако всичко е наред  ......
