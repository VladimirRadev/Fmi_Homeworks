1) генериране на псевдокод на базата на логиката от задачата


1 read a,b,c
2 arr[3] <- {a,b,c}
3 grades[3] <- {0 , 0 , 0}
4 for(i <- 0;i<3;i<- i + 1) then
5 if(arr[i] >= 1 and arr[i] <= 40) then
6    grades[i] <- 2 
7 endif
8  if(arr[i] > 40 and arr[i] <=55) then
9    grades[i] <- 3 
10 endif
11 if(arr[i]> 55 and arr[i] <= 70) then
12   grades[i] <- 4
13 endif
14 if(arr[i] > 70 and arr[i] <=85) then
15  grades[i] <- 5
16 endif
17 if(arr[i]>85 and arr[i] <= 100)then
18   grades[i] <- 6
19 endif
20 endfor
21 final_score <- 0.2*grades[0] + 0.3*grades[1] + 0.5*grades[2]
22 print(final_score)

2) Генериране на графът на управляващият поток
 -> виж resh.png
 2.1) Започваме с началният нод , който представлява началото на програмата
 2.2) Обединяваме ред 1,2,3 в реброто a
 2.3) Проверяваме броят точки на всеки един компонент във цикъл , като за всеки един компонент е оценен с точки от 1 до 100 включително като:
	2.3.1) ако е между [1;40] -> 2 (ребра а , f)
	2.3.2) ако е между (40,55] -> 3 ( rebra b,g)
	2.3.3) ако е между (55,70] -> 4 ( rebra c,h)
	2.3.4) ako e mejdu (70,85] -> 5 ( rebra d,i)
	2.3.5) ako e mejdu (85,100] -> 6 ( rebra e,j)
 2.4) ако е изпълнено условието че i<3 се връщаме към стъпка 2.3 (rebro k)
 2.5) ребра f,g,h,i,j се обединяват в общ възел
 2.6) накрая изчисляваме финалната оценка на база на формулата : 20% от оценката за семинара , 30% от курсовият проект , 50% от финалният тест в ребро l
 2.7) изпринтираме финалната оценка и терминираме програмата
